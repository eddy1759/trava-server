import { ItineraryItem, CollaboratorRole, ItineraryItemCategory, ExpenseCategory } from '@prisma/client';

import logger  from '../../utils/logger';
import ApiError from '../../utils/ApiError';
import { prisma } from '../../services/prisma';
import { CreateItineraryData, ItinerarySuggestionRequest } from './itinerary.type';
import { expenseService } from '../expense/expense.service';
import { authorizeTripAccess } from '../../middlewares/auth';
import * as locationService from '../location/location.service';
import { optimizeAIRequest } from '../../services/ai-cost-optimizer';
import { generateItinerarySuggestions } from '../../services/static-recommendations.service';
import { recommendationService, RecommendationRequest } from '../../services/recommendation.service';




const itineraryToExpenseCategoryMap: Partial<Record<ItineraryItemCategory, ExpenseCategory>> = {
    [ItineraryItemCategory.FLIGHT]: ExpenseCategory.TRANSPORT,
    [ItineraryItemCategory.HOTEL]: ExpenseCategory.LODGING,
    [ItineraryItemCategory.ACTIVITY]: ExpenseCategory.TICKETS,
    [ItineraryItemCategory.RESTAURANT]: ExpenseCategory.FOOD,
    [ItineraryItemCategory.TRANSPORTATION]: ExpenseCategory.TRANSPORT,
};


async function createItineraryItem(userId: string, data: CreateItineraryData): Promise<ItineraryItem> {
  const { tripId, locationQuery, ...itemData } = data;

  // 1. Authorize: Ensure user is an EDITOR on the trip
  await authorizeTripAccess(tripId, userId, [CollaboratorRole.EDITOR]);

  // 2. Handle Location (if provided)
  const locationId = locationQuery ? (await locationService.findOrCreateLocation(locationQuery)).id : undefined;

  // 3. Create Item and placeholder Expense in a transaction
  const result = await prisma.$transaction(async (tx) => {
    const itineraryItem = await tx.itineraryItem.create({
        data: {
            ...itemData,
            userId,
            tripId,
            locationId,
            startTime: new Date(data.startTime),
            endTime: data.endTime ? new Date(data.endTime) : undefined,
        },
        include: { location: true },
    });

    const expenseCategory = itineraryToExpenseCategoryMap[itineraryItem.category];
    if (expenseCategory) {
          await expenseService.createExpense({
            tripId,
            userId,
            description: `Placeholder for: ${itineraryItem.title}`,
            amount: 0.00, // Default amount, user can update it later
            category: expenseCategory,
            date: itineraryItem.startTime,
            isAutogenerated: true, // Mark as autogenerated
        });
        logger.info(`Automatically created placeholder expense for itinerary item: ${itineraryItem.id}`);
    }
    return itineraryItem;
  });
    
  logger.info(`Created itinerary item: ${result.title} for trip: ${tripId}`);
    return result;
};


async function getItineraryForTrip(tripId: string, userId: string): Promise<ItineraryItem[]> {
    // Authorize: Ensure user is at least a VIEWER
    await authorizeTripAccess(tripId, userId, [CollaboratorRole.VIEWER, CollaboratorRole.EDITOR]);

    return prisma.itineraryItem.findMany({
       where: { tripId },
        orderBy: { startTime: 'asc' },
        include: { location: true },
    });
}

async function getById(userId: string, itemId: string): Promise<ItineraryItem> {
  const item = await prisma.itineraryItem.findUnique({
          where: { id: itemId },
          include: { location: true },
      });
      // Authorize: User must be a viewer of the item's trip
      await authorizeTripAccess(item.tripId, userId, [CollaboratorRole.VIEWER, CollaboratorRole.EDITOR]);
      
      return item;
}


async function updateItineraryItem(id: string, userId: string, data: Partial<CreateItineraryData>): Promise<ItineraryItem> {
  const { tripId, locationQuery, ...itemData } = data;

  // 1. Fetch the original item to get its tripId for authorization
  const existingItem = await prisma.itineraryItem.findUnique({ where: { id: id } });
  if (!existingItem) {
      throw ApiError.NotFound('Itinerary item not found');
  }

  // 2. Authorize: Ensure user is an EDITOR on the trip
  await authorizeTripAccess(existingItem.tripId, userId, [CollaboratorRole.EDITOR]);

  // 2. Handle Location (if provided)
  const locationId = locationQuery ? (await locationService.findOrCreateLocation(locationQuery)).id : undefined;

  const updatedItem = await prisma.$transaction(async (tx) => {
    const item = await tx.itineraryItem.update({
        where: { id },
        data: {
            ...itemData,
            userId,
            locationId,
            startTime: data.startTime ? new Date(data.startTime) : undefined,
            endTime: data.endTime ? new Date(data.endTime) : undefined,
        },
        include: { location: true },
    });

    // If start time changed, update the linked autogenerated expense
    if (data.startTime) {
        await tx.expense.updateMany({
            where: { 
                description: `Placeholder for: ${existingItem.title}`,
                tripId: item.tripId,
                isAutogenerated: true,
            },
            data: { date: item.startTime }
        });
    }
    return item;
  });
      
  logger.info(`Updated itinerary item: ${updatedItem.id}`);
  return updatedItem;
}

async function deleteItineraryItem(id: string, userId: string): Promise<void> {
  // 1. Fetch item to get its tripId and title
  const itemToDelete = await prisma.itineraryItem.findUnique({ where: { id } });
  if (!itemToDelete) {
      // If it doesn't exist, the operation is idempotent. Return successfully.
      logger.warn(`Attempted to delete non-existent itinerary item: ${id}`);
      return;
  }

  // 2. Authorize action
  await authorizeTripAccess(itemToDelete.tripId, userId, [CollaboratorRole.EDITOR]);

  // 3. Delete the item and its linked autogenerated expense in a transaction
        await prisma.$transaction(async (tx) => {
            // Delete the placeholder expense first
             await tx.expense.deleteMany({
                where: {
                    description: `Placeholder for: ${itemToDelete.title}`,
                    tripId: itemToDelete.tripId,
                    isAutogenerated: true,
                },
            });
            // Then delete the itinerary item
            await tx.itineraryItem.delete({ where: { id } });
        });

        logger.info(`Deleted itinerary item: ${id} and its linked expense.`);
}


async function getItineraryItemsForLocation(locationId: string, userId: string): Promise<ItineraryItem[]> {
    // 1. Authorize: Ensure user is at least a VIEWER on the trip
    const location = await prisma.location.findUnique({ where: { id: locationId } });
    if (!location) throw new Error('Location not found');

    const trips = await prisma.trip.findMany({
        where: { locationId },
        include: { collaborators: true },
    });

    // Check if user has access to any of the trips
    const hasAccess = trips.some(trip =>
        trip.collaborators.some(collab => collab.userId === userId && collab.role !== CollaboratorRole.NONE)
    );

    if (!hasAccess) throw new Error('You do not have permission to view this location\'s itinerary items');

    return prisma.itineraryItem.findMany({
        where: { locationId },
        orderBy: { startTime: 'asc' },
        include: { trip: true },
    });
}

async function getItineraryItemsForUser(userId: string): Promise<ItineraryItem[]> {
    // Fetch all trips the user is a collaborator on
    const trips = await prisma.trip.findMany({
        where: {
            collaborators: {
                some: { userId, role: { not: CollaboratorRole.NONE } },
            },
        },
        select: { id: true },
    });

    if (trips.length === 0) return []; // No trips found

    const tripIds = trips.map(trip => trip.id);

    return prisma.itineraryItem.findMany({
        where: { tripId: { in: tripIds } },
        orderBy: { startTime: 'asc' },
        include: { trip: true, location: true },
    });
}



async function generateUserItinerarySuggestions(userId: string, request: ItinerarySuggestionRequest) {
  try {
    const { tripId, destinationName, startDate, endDate, budget, preferences } = request;

    // Get static recommendations first
    const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));

    const staticSuggestions = generateItinerarySuggestions(destinationName, startDate, endDate, budget);

    // Generate AI-enhanced suggestions
    const aiPrompt = buildAIPrompt(destinationName, days, budget, preferences, staticSuggestions);
    
    const aiResponse = await optimizeAIRequest({
      prompt: aiPrompt,
      userId: 'system', // Use system user for AI requests
      priority: 'medium',
      maxTokens: 1000,
      temperature: 0.7,
    });

    // Parse AI response and combine with static suggestions
    const aiSuggestions = parseAIResponse(aiResponse);
    const combinedSuggestions = [...staticSuggestions, ...aiSuggestions];

    // Create itinerary items from suggestions
    const createdItems = await createItemsFromSuggestions(tripId, userId, combinedSuggestions, startDate);

    logger.info(`Generated ${createdItems.length} itinerary suggestions for trip: ${tripId}`);
    return createdItems;
  } catch (error) {
    logger.error('Failed to generate itinerary suggestions:', error);
    throw ApiError.InternalServerError('Failed to generate itinerary suggestions');
  }
}

 
function buildAIPrompt(
    destinationName: string,
    days: number,
    budget: number,
    preferences: string[] = [],
    staticSuggestions: any[]
  ): string {
  const preferencesText = preferences.length > 0 ? `Preferences: ${preferences.join(', ')}. ` : '';

  const prompt = `
    Create a ${days}-day travel itinerary for ${destinationName} with a budget of $${budget}. ${preferencesText} Consider these existing suggestions: ${staticSuggestions.map(s => s.title).join(', ')}
    Provide 3-5 additional unique activities that complement the existing suggestions. For each activity include:
    - Title
    - Description (1-2 sentences)
    - Estimated cost
    - Duration in hours
    - Best time of day
    - 2-3 practical tips
    Format as JSON array with fields: title, description, estimatedCost, duration, bestTime, tips.
  `;

  return prompt.trim();
}


function parseAIResponse(aiResponse: string): any[] {
  try {
    // Try to extract JSON from AI response
    const jsonMatch = aiResponse.match(/\[.*\]/s);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    // Fallback: return empty array if parsing fails
    logger.warn('Failed to parse AI response as JSON:', aiResponse);
    return [];
  } catch (error) {
    logger.error('Error parsing AI response:', error);
    return [];
  }
}


async function createItemsFromSuggestions(tripId: string, userId: string, suggestions: any[], startDate: Date): Promise<any[]> {
  const createdItems = [];
  let currentDate = new Date(startDate);

  for (let i = 0; i < suggestions.length && i < 10; i++) { // Limit to 10 items
    const suggestion = suggestions[i];
    
    // Calculate start time for this item
    const startTime = new Date(currentDate);
    startTime.setHours(9 + (i % 3) * 2, 0, 0, 0); // Spread items throughout the day
    
    const endTime = new Date(startTime);
    endTime.setHours(startTime.getHours() + (suggestion.duration || 2));

    try {
      const item = await prisma.itineraryItem.create({
        data: {
          tripId,
          userId,
          title: suggestion.title,
          description: suggestion.description,
          category: suggestion.category || ItineraryItemCategory.ACTIVITY,
          startTime: new Date(startTime),
          endTime: new Date(endTime),
          isAISuggestion: true,
        }
      });
      
      createdItems.push(item);
    } catch (error) {
      logger.error(`Failed to create item from suggestion: ${suggestion.title}`, error);
    }
  }

  return createdItems;
}


async function getItineraryStats(tripId: string) {
  try {
    const items = await prisma.itineraryItem.findMany({
      where: { tripId },
      select: {
      category: true,
        isAISuggestion: true,
        startTime: true,
      },
    });

    const stats = {
      totalItems: items.length,
      aiSuggestions: items.filter(item => item.isAISuggestion).length,
      manualItems: items.filter(item => !item.isAISuggestion).length,
      categories: {} as Record<string, number>,
      daysWithActivities: new Set(items.map(item => 
        item.startTime.toISOString().split('T')[0]
      )).size,
    };

    // Count items by category
    items.forEach(item => {
      stats.categories[item.category] = (stats.categories[item.category] || 0) + 1;
    });

    return stats;
  } catch (error) {
    logger.error('Failed to get itinerary stats:', error);
    throw ApiError.InternalServerError('Failed to get itinerary stats');
  }
}


async function generateSmartItineraryRecommendations(request: RecommendationRequest) {
  try {
    const recommendations = await recommendationService.generateSmartRecommendations(request);
    
    return {
      itinerary: recommendations.itinerary,
      insights: recommendations.aiInsights,
      optimizationTips: recommendations.optimizationTips,
      totalEstimatedCost: recommendations.totalEstimatedCost,
      budgetUtilization: recommendations.budgetUtilization,
    };
  } catch (error) {
    logger.error('Failed to generate smart itinerary recommendations:', error);
    throw ApiError.InternalServerError('Failed to generate recommendations');
  }
}


async function getDestinationInsights(destinationName: string) {
  try {
    return await recommendationService.getDestinationInsights(destinationName);
  } catch (error) {
    logger.error('Failed to get destination insights:', error);
    return ['Research local customs before visiting', 'Book popular attractions in advance'];
  }
}


async function getBudgetOptimization(
    destinationName: string,
    currentBudget: number,
    currentExpenses: any[],
    preferences?: string[]
  ) {
    try {
      return await recommendationService.getBudgetOptimization(
        destinationName,
        currentBudget,
        currentExpenses,
        preferences
      );
    } catch (error) {
      logger.error('Failed to get budget optimization:', error);
      return {
        suggestions: ['Consider using public transportation', 'Look for free activities'],
        optimizedBudget: [],
      };
    }
}






export const itineraryService = {
  createItineraryItem,
  getItineraryForTrip,
  getById,
  updateItineraryItem,
  deleteItineraryItem,
  getItineraryItemsForLocation,
  getItineraryItemsForUser,
  generateUserItinerarySuggestions,
  getItineraryStats,
  generateSmartItineraryRecommendations,
  getDestinationInsights,
  getBudgetOptimization,
  createItemsFromSuggestions,
};